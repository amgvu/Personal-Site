import { CommonModule } from '@angular/common';
import { Directive, Renderer2, ElementRef, Input, NgModule } from '@angular/core';
import { combineLatest, timer, BehaviorSubject, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var InterpolationDirection = {
    FORWARD: 0,
    BACKWARD: 1,
};
InterpolationDirection[InterpolationDirection.FORWARD] = 'FORWARD';
InterpolationDirection[InterpolationDirection.BACKWARD] = 'BACKWARD';
var NgxAnimatedGradientDirective = /** @class */ (function () {
    function NgxAnimatedGradientDirective(renderer, el) {
        this.renderer = renderer;
        this.el = el;
        /**
         * A list of RGB Value tuples used to define the gradient
         */
        this.colors = [[62, 35, 255], [60, 255, 60], [255, 35, 98], [45, 175, 230], [255, 0, 255], [255, 128, 0]];
        /**
         * The tick speed for calling the update of the gradient
         */
        this.tickSpeed = 16;
        /**
         * The color indices, these indicate where in the color table to load from
         * The order is as follows:
         *   Current left, Next left, Current right, Next right
         */
        this.colorIndices = [0, 1, 2, 3];
        /**
         * The multiplier for the gradient speed
         */
        this.gradientSpeed = 0.002;
        this.direction = InterpolationDirection.FORWARD;
        this.step$ = new BehaviorSubject(0);
        this.componentDestroyed$ = new Subject();
        this.gradientRunning$ = new BehaviorSubject(true);
    }
    /**
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        combineLatest(timer(0, this.tickSpeed), this.gradientRunning$)
            .pipe(takeUntil(this.componentDestroyed$))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _ = _a[0], gradientRunning = _a[1];
            if (gradientRunning) {
                /** @type {?} */
                var result = _this.direction === InterpolationDirection.FORWARD
                    ? _this.step$.value + _this.gradientSpeed
                    : _this.step$.value - _this.gradientSpeed;
                if (result >= 1) {
                    _this.direction = InterpolationDirection.BACKWARD;
                    result = 1;
                }
                else if (result <= 0) {
                    _this.direction = InterpolationDirection.FORWARD;
                    result = 0;
                }
                _this.step$.next(result);
            }
        }));
        /**
         * Combine the timer and gradient running to trigger rendering
         */
        combineLatest(this.step$, this.gradientRunning$)
            .pipe(takeUntil(this.componentDestroyed$))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var step = _a[0], gradientRunning = _a[1];
            return gradientRunning && _this.render(_this.generateColour(step), step);
        }));
    };
    /**
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.gradientRunning$.next(false);
        this.componentDestroyed$.next(true);
        this.gradientRunning$.complete();
        this.componentDestroyed$.complete();
    };
    /**
     * @private
     * @param {?} index
     * @param {?} step
     * @param {?} value1
     * @param {?} value2
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.createColor = /**
     * @private
     * @param {?} index
     * @param {?} step
     * @param {?} value1
     * @param {?} value2
     * @return {?}
     */
    function (index, step, value1, value2) {
        /** @type {?} */
        var red = Math.round(index * value1[0] + step * value2[0]);
        /** @type {?} */
        var green = Math.round(index * value1[1] + step * value2[1]);
        /** @type {?} */
        var blue = Math.round(index * value1[2] + step * value2[2]);
        return "rgb(" + red + ", " + green + ", " + blue + ")";
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.getNewColour = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return (this.colorIndices[index] + Math.floor(1 + Math.random() * (this.colors.length - 1))) % this.colors.length;
    };
    /**
     * @private
     * @param {?} step
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.generateColour = /**
     * @private
     * @param {?} step
     * @return {?}
     */
    function (step) {
        /** @type {?} */
        var stepIndex = 1 - step;
        /** @type {?} */
        var color1 = this.createColor(stepIndex, step, this.colors[this.colorIndices[0]], this.colors[this.colorIndices[1]]);
        /** @type {?} */
        var color2 = this.createColor(stepIndex, step, this.colors[this.colorIndices[2]], this.colors[this.colorIndices[3]]);
        return [color1, color2];
    };
    /**
     * Start the directive gradient animation
     */
    /**
     * Start the directive gradient animation
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.start = /**
     * Start the directive gradient animation
     * @return {?}
     */
    function () {
        this.gradientRunning$.next(true);
    };
    /**
     * Stop the directive gradient animation
     */
    /**
     * Stop the directive gradient animation
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.stop = /**
     * Stop the directive gradient animation
     * @return {?}
     */
    function () {
        this.gradientRunning$.next(false);
    };
    /**
     * Set a new palette for the animation
     */
    /**
     * Set a new palette for the animation
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.newPalette = /**
     * Set a new palette for the animation
     * @return {?}
     */
    function () {
        this.colorIndices[0] = this.colorIndices[1];
        this.colorIndices[2] = this.colorIndices[3];
        // pick two new target color indices
        // do not pick the same as the current one
        this.colorIndices[1] = this.getNewColour(1);
        this.colorIndices[3] = this.getNewColour(3);
    };
    /**
     * Update the gradient animation
     */
    /**
     * Update the gradient animation
     * @param {?} renderValue
     * @param {?} step
     * @return {?}
     */
    NgxAnimatedGradientDirective.prototype.render = /**
     * Update the gradient animation
     * @param {?} renderValue
     * @param {?} step
     * @return {?}
     */
    function (renderValue, step) {
        this.renderer.setStyle(this.el.nativeElement, 'background', "-webkit-gradient(linear, left top, right top, from(" + renderValue[0] + "), to(" + renderValue[1] + "))");
        this.renderer.setStyle(this.el.nativeElement, 'background', "-moz-linear-gradient(left, " + renderValue[0] + " 0%, " + renderValue[1] + " 100%)");
    };
    NgxAnimatedGradientDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngxAnimatedGradient]'
                },] },
    ];
    /** @nocollapse */
    NgxAnimatedGradientDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    NgxAnimatedGradientDirective.propDecorators = {
        colors: [{ type: Input }],
        tickSpeed: [{ type: Input }],
        colorIndices: [{ type: Input }],
        gradientSpeed: [{ type: Input }]
    };
    return NgxAnimatedGradientDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxAnimatedGradientModule = /** @class */ (function () {
    function NgxAnimatedGradientModule() {
    }
    NgxAnimatedGradientModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [NgxAnimatedGradientDirective],
                    declarations: [NgxAnimatedGradientDirective]
                },] },
    ];
    return NgxAnimatedGradientModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxAnimatedGradientDirective, NgxAnimatedGradientModule };
//# sourceMappingURL=ngx-animated-gradient.es5.js.map
