(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global.ngxAnimatedGradient = {}, global.ng.common, global.ng.core, global.rxjs, global.operators));
}(this, function (exports, common, core, rxjs, operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var InterpolationDirection = {
        FORWARD: 0,
        BACKWARD: 1,
    };
    InterpolationDirection[InterpolationDirection.FORWARD] = 'FORWARD';
    InterpolationDirection[InterpolationDirection.BACKWARD] = 'BACKWARD';
    var NgxAnimatedGradientDirective = /** @class */ (function () {
        function NgxAnimatedGradientDirective(renderer, el) {
            this.renderer = renderer;
            this.el = el;
            /**
             * A list of RGB Value tuples used to define the gradient
             */
            this.colors = [[62, 35, 255], [60, 255, 60], [255, 35, 98], [45, 175, 230], [255, 0, 255], [255, 128, 0]];
            /**
             * The tick speed for calling the update of the gradient
             */
            this.tickSpeed = 16;
            /**
             * The color indices, these indicate where in the color table to load from
             * The order is as follows:
             *   Current left, Next left, Current right, Next right
             */
            this.colorIndices = [0, 1, 2, 3];
            /**
             * The multiplier for the gradient speed
             */
            this.gradientSpeed = 0.002;
            this.direction = InterpolationDirection.FORWARD;
            this.step$ = new rxjs.BehaviorSubject(0);
            this.componentDestroyed$ = new rxjs.Subject();
            this.gradientRunning$ = new rxjs.BehaviorSubject(true);
        }
        /**
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            rxjs.combineLatest(rxjs.timer(0, this.tickSpeed), this.gradientRunning$)
                .pipe(operators.takeUntil(this.componentDestroyed$))
                .subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _ = _a[0], gradientRunning = _a[1];
                if (gradientRunning) {
                    /** @type {?} */
                    var result = _this.direction === InterpolationDirection.FORWARD
                        ? _this.step$.value + _this.gradientSpeed
                        : _this.step$.value - _this.gradientSpeed;
                    if (result >= 1) {
                        _this.direction = InterpolationDirection.BACKWARD;
                        result = 1;
                    }
                    else if (result <= 0) {
                        _this.direction = InterpolationDirection.FORWARD;
                        result = 0;
                    }
                    _this.step$.next(result);
                }
            }));
            /**
             * Combine the timer and gradient running to trigger rendering
             */
            rxjs.combineLatest(this.step$, this.gradientRunning$)
                .pipe(operators.takeUntil(this.componentDestroyed$))
                .subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var step = _a[0], gradientRunning = _a[1];
                return gradientRunning && _this.render(_this.generateColour(step), step);
            }));
        };
        /**
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.gradientRunning$.next(false);
            this.componentDestroyed$.next(true);
            this.gradientRunning$.complete();
            this.componentDestroyed$.complete();
        };
        /**
         * @private
         * @param {?} index
         * @param {?} step
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.createColor = /**
         * @private
         * @param {?} index
         * @param {?} step
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        function (index, step, value1, value2) {
            /** @type {?} */
            var red = Math.round(index * value1[0] + step * value2[0]);
            /** @type {?} */
            var green = Math.round(index * value1[1] + step * value2[1]);
            /** @type {?} */
            var blue = Math.round(index * value1[2] + step * value2[2]);
            return "rgb(" + red + ", " + green + ", " + blue + ")";
        };
        /**
         * @private
         * @param {?} index
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.getNewColour = /**
         * @private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return (this.colorIndices[index] + Math.floor(1 + Math.random() * (this.colors.length - 1))) % this.colors.length;
        };
        /**
         * @private
         * @param {?} step
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.generateColour = /**
         * @private
         * @param {?} step
         * @return {?}
         */
        function (step) {
            /** @type {?} */
            var stepIndex = 1 - step;
            /** @type {?} */
            var color1 = this.createColor(stepIndex, step, this.colors[this.colorIndices[0]], this.colors[this.colorIndices[1]]);
            /** @type {?} */
            var color2 = this.createColor(stepIndex, step, this.colors[this.colorIndices[2]], this.colors[this.colorIndices[3]]);
            return [color1, color2];
        };
        /**
         * Start the directive gradient animation
         */
        /**
         * Start the directive gradient animation
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.start = /**
         * Start the directive gradient animation
         * @return {?}
         */
        function () {
            this.gradientRunning$.next(true);
        };
        /**
         * Stop the directive gradient animation
         */
        /**
         * Stop the directive gradient animation
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.stop = /**
         * Stop the directive gradient animation
         * @return {?}
         */
        function () {
            this.gradientRunning$.next(false);
        };
        /**
         * Set a new palette for the animation
         */
        /**
         * Set a new palette for the animation
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.newPalette = /**
         * Set a new palette for the animation
         * @return {?}
         */
        function () {
            this.colorIndices[0] = this.colorIndices[1];
            this.colorIndices[2] = this.colorIndices[3];
            // pick two new target color indices
            // do not pick the same as the current one
            this.colorIndices[1] = this.getNewColour(1);
            this.colorIndices[3] = this.getNewColour(3);
        };
        /**
         * Update the gradient animation
         */
        /**
         * Update the gradient animation
         * @param {?} renderValue
         * @param {?} step
         * @return {?}
         */
        NgxAnimatedGradientDirective.prototype.render = /**
         * Update the gradient animation
         * @param {?} renderValue
         * @param {?} step
         * @return {?}
         */
        function (renderValue, step) {
            this.renderer.setStyle(this.el.nativeElement, 'background', "-webkit-gradient(linear, left top, right top, from(" + renderValue[0] + "), to(" + renderValue[1] + "))");
            this.renderer.setStyle(this.el.nativeElement, 'background', "-moz-linear-gradient(left, " + renderValue[0] + " 0%, " + renderValue[1] + " 100%)");
        };
        NgxAnimatedGradientDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngxAnimatedGradient]'
                    },] },
        ];
        /** @nocollapse */
        NgxAnimatedGradientDirective.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        NgxAnimatedGradientDirective.propDecorators = {
            colors: [{ type: core.Input }],
            tickSpeed: [{ type: core.Input }],
            colorIndices: [{ type: core.Input }],
            gradientSpeed: [{ type: core.Input }]
        };
        return NgxAnimatedGradientDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxAnimatedGradientModule = /** @class */ (function () {
        function NgxAnimatedGradientModule() {
        }
        NgxAnimatedGradientModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [NgxAnimatedGradientDirective],
                        declarations: [NgxAnimatedGradientDirective]
                    },] },
        ];
        return NgxAnimatedGradientModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NgxAnimatedGradientDirective = NgxAnimatedGradientDirective;
    exports.NgxAnimatedGradientModule = NgxAnimatedGradientModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-animated-gradient.umd.js.map
